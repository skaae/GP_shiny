{
    "contents" : "library(R.matlab)\nrequire(\"randomForestSRC\")\nsetwd(\"~/Documents/Speciale/breast_cancer\")\nsource(\"R_files/aucs.R\")\nrun_rsf_hyper = F \n### Load data from matlab ###\n# The matlab script running GP saves the data used. Use this data to ensure train\n# and test sets / normalization etc is equal\nf_mat = \"datasets/Processed/matlab_GP_output.mat\"\nf.res = \"cache/rsf_hyperparams\" \ndata <- readMat(f_mat)\n\nsamples.train = data$train.samples\nsamples.test = data$test.samples\n\ndata.nan = data$data.nan\ndata.nan[is.na(data.nan)] <- NA\nx.normalized.train <- data.frame(data.nan[samples.train,])\nx.normalized.test <- data.frame(data.nan[samples.test,])\n\ny.train <- data.frame(data$ytr)\ny.test <- data.frame(data$yt)\nye.train <- data.frame(data$yetr)\nye.test <- data.frame(data$yet)\n\n\n### Create data in format for rfsrc ###\ncolumns <- c('y','ye','age','node','tumorsize','grade','her2','er',\n             'treatment_any','treatment_RT','treatment_CT','treatment_HT')\ndata.train <- data.frame(cbind(y.train,ye.train,x.normalized.train))\ndata.test  <- data.frame(cbind(y.test,ye.test,x.normalized.test))\ncolnames(data.train) <- columns\ncolnames(data.test) <- columns\ncolnames(data.nan) <- columns[3:length(columns)]\n### train a forest with 1000 trees ###\n\n\n#try with data where nans are not replaced....\n#optimize the number of candidate features used at each split -> mtry\n# optimize minimum node size for survival\n\n# SPLITTING RULE\n# Interestingly, RSF using the logrankrandom splitting rule was good in\n# all examples. Because this splitting rule is significantly faster, its per-\n#  formance suggests it might be the preferred method in settin gs where\n# computational speed is essential.\n\n \n\nmtry = seq(1,dim(data.nan)[2],2)\nnodesize = c(1,3,5,9)\nhyperparams = expand.grid(mtry,nodesize)\n\nif(run_rsf_hyper=T){\nauc.train = c()\nauc.test = c()\nfor(i in 1:nrow(hyperparams)){\n  mt = hyperparams[i,1]   #mtry\n  ns = hyperparams[i,2]   #nodesize\n  model <- rfsrc(Surv(y,ye) ~ . ,\n                 data.train, ntree=1000, forest=T,\n                 na.action = \"na.impute\", mtry=mt,nodesize=ns,nimpute=2)\n  pred.train <- predict(model, data.train,na.action =\"na.impute\")\n  pred.test  <- predict(model, data.test,na.action =\"na.impute\")\n  auc.train  <- c(auc.train, aucs(-1*pred.train$yvar$y,pred.train$yvar$ye))\n  auc.test   <- c(auc.test,  aucs(-1*pred.test$yvar$y,pred.test$yvar$ye))\n  print(auc.train)\n  print(i)\n}\n\n# find optimal number of impute iterations\n# The o\n# first extract data with no nans artificially intoduce nans in this data\n\nfrac.nan = sum(is.na(data.nan)) / prod(dim(data.nan))\nvalid = rowSums(is.na(data.nan)) == 0\ndata.nonans = data.nan[valid,]\nmask.removed = matrix(sample(c(T,F), size = prod(dim(data.nan)), replace = T,\n                             prob = c(frac.nan, 1-frac.nan)), \n                      nrow = dim(data.nan)[1], ncol = dim(data.nan)[2])\ndata.nonans.test = data.nonans.test * !mask.removed\ndata.nonans.test[data.nonans.test == 0] = NA\n\ndata.impute = cbind(y.train[valid,],ye.train[valid,],data.nonans.test)\ncolnames(data.impute) <- columns\n\nimp.res = c()\nfor(i in 1:10){\nimp = impute.rfsrc(Surv(y,ye) ~ . ,\n                   data.impute, ntree=1000, forest=T,nimpute=i)\n\nd = sqrt( (data.nonans-imp[,3:ncol(imp)])^2 ) / sum(mask.removed)\nres <- sum(d)\nimp.res = c(imp.res,res)\n}\n\nsave(imp.res,file=f.res)\n}else{\n  load(f.res)\n}\n\n#undersÃ¸g om predict laver na.impute automatisk\n\n### Evalute performance ###\n\n\n\n\nauc.test <- aucs(-1*pred.test$yvar$y,preds.test$yvar$ye)\nplot(auc$false_pos,auc$true_pos,type='l')\n\ninteraction <- find.interaction(v.out)\nprint(v.out)\nplot(v.out)\n\n\n\n\n",
    "created" : 1389017200560.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "913468800",
    "id" : "14E5F280",
    "lastKnownWriteTime" : 1389018210,
    "path" : "~/Documents/Speciale/breast_cancer/R_files/rsf_test.R",
    "project_path" : null,
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}